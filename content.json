{"meta":{"title":"CHANG","subtitle":"所有的理想主义者都在脚踏实地","description":null,"author":"Chase Liu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2019-10-27T12:42:42.000Z","updated":"2019-10-27T12:44:37.134Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-27T11:57:50.000Z","updated":"2019-10-27T12:50:46.375Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"#随笔"}],"posts":[{"title":"can2serials_lib","slug":"can2serials-lib","date":"2019-10-27T14:43:46.000Z","updated":"2019-10-27T14:55:11.236Z","comments":true,"path":"2019/10/27/can2serials-lib/","link":"","permalink":"http://yoursite.com/2019/10/27/can2serials-lib/","excerpt":"","text":"CAN分析仪驱动 完成CAN到串口的数据解析，同时向CAN分析仪发送数据 数据解析流程：1.StarReading() : 开启ReadSerialPort()线程 2.ReadSerialPort() : 从serial读数据到buffer临时变量 3.BufferInComingData() : 遍历整个从串口读到的buffer，得到一帧完整的数据存于类成员data_buffer_（头+数据+校验位）后，按照通信协议调用parse()对数据含义进行解析 4.prase() : 解析一帧完整数据的含义，根据帧ID提取数据位。如果是下位机CAN消息，用canMsg_结构体变量存储CAN消息，并将其写入专门存放CAN消息的buffercanMsgBuf_[]中 整个ReadingSerilPort套在while循环下，保证线程持续读数据，解析数据。 取消字节对齐注意宏定义及其及使用 1234567891011121314151617181920212223242526272829#define PACK( __Declaration__ ) __Declaration__ __attribute__((__packed__))PACK(struct stdCanMsgPkg_t &#123; uint8_t header1; //66 uint8_t header2; //cc uint16_t pkg_len; uint8_t pkg_cmd; //B1 stdCanMsg uint8_t type; //frame type uint32_t frame_id; uint8_t frame_len; uint8_t data[8]; uint8_t checknum;&#125;);PACK(struct inquireFilterResponsePkg_t &#123; uint8_t header1; //66 uint8_t header2; //cc uint16_t pkg_len; uint8_t pkg_cmd; //9D inquire Filter Response uint8_t result; uint8_t portNum; uint8_t filterNum; uint32_t filterID; uint32_t filterMask; uint8_t filterMode; uint8_t checknum;&#125;); 在类成员函数中开启另外一个类成员函数的线程12345678910void Can2serial::StartReading() &#123; if (reading_status_) return; //serial_port_-&gt;flush(); // create thread to read from sensor reading_status_=true; read_thread_ptr_ = boost::shared_ptr&lt;boost::thread &gt;(new boost::thread(boost::bind(&amp;Can2serial::ReadSerialPort, this)));&#125; 解析出一帧完整的数据包注意case2 case3 中 bytes_remaining的应用，该变量用于保存剩余未解析数据的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void Can2serial::BufferIncomingData(unsigned char *message, unsigned int length)&#123; // add incoming data to buffer for (unsigned int ii=0; ii&lt;length; ii++) &#123;// make sure bufIndex is not larger than buffer if(buffer_index_&gt;=MAX_PKG_BUF_LEN) &#123; buffer_index_ = 0; printf(\"Overflowed receive buffer. Buffer cleared.\"); &#125; //std::cout &lt;&lt; \"bytes_remaining_...:\" &lt;&lt;bytes_remaining_ &lt;&lt;std::endl; switch(buffer_index_) &#123; case 0: //nothing if(message[ii]==HeaderByte0) &#123; data_buffer_[buffer_index_++]=message[ii]; &#125; bytes_remaining_ = 0; break; case 1: if(message[ii]==HeaderByte1) &#123; data_buffer_[buffer_index_++]=message[ii]; bytes_remaining_ =2; //2 bytes pkgLen &#125; else &#123; buffer_index_=0; bytes_remaining_ =0; &#125; break; case 2: case 3: data_buffer_[buffer_index_++]=message[ii]; bytes_remaining_ --; if(bytes_remaining_==0) &#123; package_len_ = (data_buffer_[buffer_index_-2] &lt;&lt; 8)+data_buffer_[buffer_index_-1] ; bytes_remaining_ = package_len_; if(bytes_remaining_ &gt; 16 || bytes_remaining_&lt;2) &#123; buffer_index_ = 0; break; &#125; //printf(\"\\t%x\\t%x\\n\",data_buffer_[buffer_index_-2],data_buffer_[buffer_index_-1]); &#125; break; default: data_buffer_[buffer_index_++]=message[ii]; bytes_remaining_--; if(bytes_remaining_==0) &#123; //std::cout &lt;&lt; \"package_len_...:\" &lt;&lt;package_len_ &lt;&lt; std::endl; parse(data_buffer_,package_len_+4); buffer_index_ = 0; &#125; break; &#125; &#125; ntohl()，将网络字节顺序（大端模式）转换成主机顺序（intel，小端顺序）12345case InquireFilterResponse: if((ntohl(inquire_filter_response_ptr_-&gt;filterID)&gt;&gt;21)!=0) printf(&quot;filter_num:%x\\t filterID:%x\\t filterMask:%x\\r\\n&quot;, inquire_filter_response_ptr_-&gt;filterNum,ntohl(inquire_filter_response_ptr_-&gt;filterID)&gt;&gt;21, ntohl(inquire_filter_response_ptr_-&gt;filterMask)&gt;&gt;21); 串口初始化123456789101112131415161718192021222324252627282930313233static bool openSerial(serial::Serial* &amp; port_ptr, std::string port_name,int baud_rate)//这个地方传进来的是port_ptr引用,底下就可以修改了Serials对象了&#123; try &#123; port_ptr = new serial::Serial(port_name,baud_rate,serial::Timeout::simpleTimeout(10)); if (!port_ptr-&gt;isOpen()) &#123; std::stringstream output; output &lt;&lt; &quot;Serial port: &quot; &lt;&lt; port_name &lt;&lt; &quot; failed to open.&quot; &lt;&lt; std::endl; delete port_ptr; port_ptr = NULL; return false; &#125; else &#123; std::stringstream output; output &lt;&lt; &quot;Serial port: &quot; &lt;&lt; port_name &lt;&lt; &quot; opened successfully.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; output.str() &lt;&lt;std::endl; &#125; port_ptr-&gt;flush(); &#125; catch (std::exception &amp;e) &#123; std::stringstream output; output &lt;&lt; &quot;Error &quot; &lt;&lt; port_name &lt;&lt; &quot;: &quot; &lt;&lt; e.what(); std::cout &lt;&lt; output.str() &lt;&lt;std::endl; return false; &#125; return true; 线程锁，对CAN消息的读写操作时均需要12345678910111213//向canMSgBuf中写入数据 &#123; boost::mutex::scoped_lock lock(mutex_); canMsgBuf_[writeIndex_] = canMsg_; canMsgStatus[writeIndex_] = true;&#125;//从canMsgBuf中读数据&#123; boost::mutex::scoped_lock lock(mutex_); msg = canMsgBuf_[readIndex_]; canMsgStatus[readIndex_]=false; &#125;","categories":[{"name":"littleAntDriverless","slug":"littleAntDriverless","permalink":"http://yoursite.com/categories/littleAntDriverless/"}],"tags":[{"name":"CAN","slug":"CAN","permalink":"http://yoursite.com/tags/CAN/"}]},{"title":"建站前言","slug":"建站前言","date":"2019-10-27T07:35:39.000Z","updated":"2019-10-27T15:42:46.280Z","comments":true,"path":"2019/10/27/建站前言/","link":"","permalink":"http://yoursite.com/2019/10/27/%E5%BB%BA%E7%AB%99%E5%89%8D%E8%A8%80/","excerpt":"","text":"&emsp;花了整整一个下午加一晚上的时间来配置个人博客，从最初安装Nodejs，然后在github上部署hexo整个过程遇到了不少的坑。虽说花了不少时间，但还是学到了点东西也算值得。&emsp;这回费这么大劲建立个人博客的目的在于： 督促自己复盘每月甚至每周的生活； 每次看书或者有其它提升能力的时候，可以强迫自己写笔记记录下来，有助于思考； 每当遇到网络上搜索不到的问题，解决后记录防止以后再遇到此类问题； 记录一下自己的生活,帮助自己认清自己，也帮助其他人了解我这种社交网络小透明； *The one thing in my life I did right was giving my heart to you! My life has been so much better since the day that I was lucky enough to find you. *","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/%E6%80%9D%E8%80%83/"}]}]}