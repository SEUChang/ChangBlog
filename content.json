{"meta":{"title":"CHANG","subtitle":"所有的理想主义者都在脚踏实地","description":null,"author":"Chase Liu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-10-27T11:57:50.000Z","updated":"2019-10-27T12:50:46.375Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"#随笔"},{"title":"标签","date":"2019-10-27T12:42:42.000Z","updated":"2019-10-27T12:44:37.134Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"宝贝若桐.md","slug":"宝贝若桐-md","date":"2019-10-27T17:20:59.000Z","updated":"2019-10-27T17:22:03.611Z","comments":true,"path":"2019/10/28/宝贝若桐-md/","link":"","permalink":"http://yoursite.com/2019/10/28/%E5%AE%9D%E8%B4%9D%E8%8B%A5%E6%A1%90-md/","excerpt":"","text":"&emsp;&emsp;说起来还真有点难过，我竟不记得是什么时候认识的若桐，或许是9月28，没准是29号，总之这不重要，因为她说我们还没有纪念日，不管哪天认识的，或是哪天确定要在一起的，都不能成为纪念日。若桐说这句话的时候是她最可爱的时候，我仿佛能看到她满怀期待等待纪念日到来的眼神，这种憧憬，把我对不能见到她的失落遮盖了不少。&emsp;&emsp;若桐的可爱远不止于此，所以我要记下来，不开心的时候看一看，开心的时候得再记上一笔，等积攒到足够多后给更多人看，不管他们能不能get到若桐可爱的点，我都愿意多费点口舌来解释，因为我想让身边的人都知道若桐有多可爱。若桐会尝试接受我只有一米五的现实，并为此困扰良久却又不来找我确认实情。若桐会假装对我的过去不在乎，看上去一脸无所谓的样子，其实满脸写着不高兴。若桐会在深夜里瞎想，会情绪低落到说很多丧气话，反过来还要安慰我不要想太多。若桐会因为学习数学的不顺利，考前的低效率而自责懊恼。若桐会一边抱怨自己在吃上花钱太多，却又总是忍不住去和姐妹每顿吃大餐。这么看来，我实在太坏了，我只有在知道若桐难过的时候才会感到心脏绞痛无力，当若桐摆脱负面情绪后，我每次回想起来，都想轻轻捧着她的脸大笑一场。我想我不该笑，一点也不应该，因为若桐大多数时候都是因为我在难过，她的可爱是她特有的表达爱的方式，一种毫无保留，纯粹自然的表达方式，所以我得和她一样，喜欢就要大声说出来。确实如此，像我这也一个不善于直抒胸臆的人，认识若桐后也变得不像自己了，会自然地想去对她说那些臊皮的情话，会无视世俗眼光，用文字或语言把自己对她的爱直接的表达出来。&emsp;&emsp;和若桐在一起的时候免不了思考人生，会想很多，想到自己的规划，会担心她受的委屈，但无论想写什么，或者怎么想，想到的结果总是只有一个，那就是要不顾一切阻力，跟若桐在一起。我怕若桐是不懂事太年轻才愿意和我一起，和我一起走过一段注定不会平坦的路，所以我用了很多话来提醒她，但她似乎都没有在怕过，倒是和之前一样反过来鼓励我。她的话总能让我感动到鼻子有点酸，仿佛我才是那个畏首畏尾不成熟的人。&emsp;&emsp;有两件事情，让我真正意识到我对若桐的感情，坚定了我不顾一切和若桐一起的信念。一件是若桐那天看到我前任照片，难过的不想说话，那时候我好害怕要失去她，我去翻遍了她所有的社交网络，才意识到她遭受的痛苦有多大，也是那时候我才明白原来心痛这词不是夸张，人在绝望的时候心脏真的会像被手掌紧紧捏住一样喘不过气，可她不愿意和我讲，我也套不出她的话，一时间焦急和心痛交织在一起，混着不能立刻抱住她的那种无力感，我一下就瘫软在床上使不上一点劲。第二件事情是若桐害怕发了自己自拍后我会删掉他，她一个下午也没怎么理我，一直在担心我们会分开。那个下午我在外面，一直有点恍惚精神没办法集中。后来知道她整个在努力拍照，我不知道应该笑还是哭，总之一点也生不起气。 未完待续","categories":[],"tags":[]},{"title":"can2serials_lib","slug":"can2serials-lib","date":"2019-10-27T14:43:46.000Z","updated":"2019-10-27T14:55:11.236Z","comments":true,"path":"2019/10/27/can2serials-lib/","link":"","permalink":"http://yoursite.com/2019/10/27/can2serials-lib/","excerpt":"","text":"CAN分析仪驱动 完成CAN到串口的数据解析，同时向CAN分析仪发送数据 数据解析流程：1.StarReading() : 开启ReadSerialPort()线程 2.ReadSerialPort() : 从serial读数据到buffer临时变量 3.BufferInComingData() : 遍历整个从串口读到的buffer，得到一帧完整的数据存于类成员data_buffer_（头+数据+校验位）后，按照通信协议调用parse()对数据含义进行解析 4.prase() : 解析一帧完整数据的含义，根据帧ID提取数据位。如果是下位机CAN消息，用canMsg_结构体变量存储CAN消息，并将其写入专门存放CAN消息的buffercanMsgBuf_[]中 整个ReadingSerilPort套在while循环下，保证线程持续读数据，解析数据。 取消字节对齐注意宏定义及其及使用 1234567891011121314151617181920212223242526272829#define PACK( __Declaration__ ) __Declaration__ __attribute__((__packed__))PACK(struct stdCanMsgPkg_t &#123; uint8_t header1; //66 uint8_t header2; //cc uint16_t pkg_len; uint8_t pkg_cmd; //B1 stdCanMsg uint8_t type; //frame type uint32_t frame_id; uint8_t frame_len; uint8_t data[8]; uint8_t checknum;&#125;);PACK(struct inquireFilterResponsePkg_t &#123; uint8_t header1; //66 uint8_t header2; //cc uint16_t pkg_len; uint8_t pkg_cmd; //9D inquire Filter Response uint8_t result; uint8_t portNum; uint8_t filterNum; uint32_t filterID; uint32_t filterMask; uint8_t filterMode; uint8_t checknum;&#125;); 在类成员函数中开启另外一个类成员函数的线程12345678910void Can2serial::StartReading() &#123; if (reading_status_) return; //serial_port_-&gt;flush(); // create thread to read from sensor reading_status_=true; read_thread_ptr_ = boost::shared_ptr&lt;boost::thread &gt;(new boost::thread(boost::bind(&amp;Can2serial::ReadSerialPort, this)));&#125; 解析出一帧完整的数据包注意case2 case3 中 bytes_remaining的应用，该变量用于保存剩余未解析数据的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void Can2serial::BufferIncomingData(unsigned char *message, unsigned int length)&#123; // add incoming data to buffer for (unsigned int ii=0; ii&lt;length; ii++) &#123;// make sure bufIndex is not larger than buffer if(buffer_index_&gt;=MAX_PKG_BUF_LEN) &#123; buffer_index_ = 0; printf(\"Overflowed receive buffer. Buffer cleared.\"); &#125; //std::cout &lt;&lt; \"bytes_remaining_...:\" &lt;&lt;bytes_remaining_ &lt;&lt;std::endl; switch(buffer_index_) &#123; case 0: //nothing if(message[ii]==HeaderByte0) &#123; data_buffer_[buffer_index_++]=message[ii]; &#125; bytes_remaining_ = 0; break; case 1: if(message[ii]==HeaderByte1) &#123; data_buffer_[buffer_index_++]=message[ii]; bytes_remaining_ =2; //2 bytes pkgLen &#125; else &#123; buffer_index_=0; bytes_remaining_ =0; &#125; break; case 2: case 3: data_buffer_[buffer_index_++]=message[ii]; bytes_remaining_ --; if(bytes_remaining_==0) &#123; package_len_ = (data_buffer_[buffer_index_-2] &lt;&lt; 8)+data_buffer_[buffer_index_-1] ; bytes_remaining_ = package_len_; if(bytes_remaining_ &gt; 16 || bytes_remaining_&lt;2) &#123; buffer_index_ = 0; break; &#125; //printf(\"\\t%x\\t%x\\n\",data_buffer_[buffer_index_-2],data_buffer_[buffer_index_-1]); &#125; break; default: data_buffer_[buffer_index_++]=message[ii]; bytes_remaining_--; if(bytes_remaining_==0) &#123; //std::cout &lt;&lt; \"package_len_...:\" &lt;&lt;package_len_ &lt;&lt; std::endl; parse(data_buffer_,package_len_+4); buffer_index_ = 0; &#125; break; &#125; &#125; ntohl()，将网络字节顺序（大端模式）转换成主机顺序（intel，小端顺序）12345case InquireFilterResponse: if((ntohl(inquire_filter_response_ptr_-&gt;filterID)&gt;&gt;21)!=0) printf(&quot;filter_num:%x\\t filterID:%x\\t filterMask:%x\\r\\n&quot;, inquire_filter_response_ptr_-&gt;filterNum,ntohl(inquire_filter_response_ptr_-&gt;filterID)&gt;&gt;21, ntohl(inquire_filter_response_ptr_-&gt;filterMask)&gt;&gt;21); 串口初始化123456789101112131415161718192021222324252627282930313233static bool openSerial(serial::Serial* &amp; port_ptr, std::string port_name,int baud_rate)//这个地方传进来的是port_ptr引用,底下就可以修改了Serials对象了&#123; try &#123; port_ptr = new serial::Serial(port_name,baud_rate,serial::Timeout::simpleTimeout(10)); if (!port_ptr-&gt;isOpen()) &#123; std::stringstream output; output &lt;&lt; &quot;Serial port: &quot; &lt;&lt; port_name &lt;&lt; &quot; failed to open.&quot; &lt;&lt; std::endl; delete port_ptr; port_ptr = NULL; return false; &#125; else &#123; std::stringstream output; output &lt;&lt; &quot;Serial port: &quot; &lt;&lt; port_name &lt;&lt; &quot; opened successfully.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; output.str() &lt;&lt;std::endl; &#125; port_ptr-&gt;flush(); &#125; catch (std::exception &amp;e) &#123; std::stringstream output; output &lt;&lt; &quot;Error &quot; &lt;&lt; port_name &lt;&lt; &quot;: &quot; &lt;&lt; e.what(); std::cout &lt;&lt; output.str() &lt;&lt;std::endl; return false; &#125; return true; 线程锁，对CAN消息的读写操作时均需要12345678910111213//向canMSgBuf中写入数据 &#123; boost::mutex::scoped_lock lock(mutex_); canMsgBuf_[writeIndex_] = canMsg_; canMsgStatus[writeIndex_] = true;&#125;//从canMsgBuf中读数据&#123; boost::mutex::scoped_lock lock(mutex_); msg = canMsgBuf_[readIndex_]; canMsgStatus[readIndex_]=false; &#125;","categories":[{"name":"littleAntDriverless","slug":"littleAntDriverless","permalink":"http://yoursite.com/categories/littleAntDriverless/"}],"tags":[{"name":"CAN","slug":"CAN","permalink":"http://yoursite.com/tags/CAN/"}]},{"title":"建站前言","slug":"建站前言","date":"2019-10-27T07:35:39.000Z","updated":"2019-10-27T15:42:46.280Z","comments":true,"path":"2019/10/27/建站前言/","link":"","permalink":"http://yoursite.com/2019/10/27/%E5%BB%BA%E7%AB%99%E5%89%8D%E8%A8%80/","excerpt":"","text":"&emsp;花了整整一个下午加一晚上的时间来配置个人博客，从最初安装Nodejs，然后在github上部署hexo整个过程遇到了不少的坑。虽说花了不少时间，但还是学到了点东西也算值得。&emsp;这回费这么大劲建立个人博客的目的在于： 督促自己复盘每月甚至每周的生活； 每次看书或者有其它提升能力的时候，可以强迫自己写笔记记录下来，有助于思考； 每当遇到网络上搜索不到的问题，解决后记录防止以后再遇到此类问题； 记录一下自己的生活,帮助自己认清自己，也帮助其他人了解我这种社交网络小透明； *The one thing in my life I did right was giving my heart to you! My life has been so much better since the day that I was lucky enough to find you. *","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/%E6%80%9D%E8%80%83/"}]}]}