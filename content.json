{"meta":{"title":"CHANG","subtitle":"所有的理想主义者都在脚踏实地","description":null,"author":"Chase Liu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-10-27T11:57:50.000Z","updated":"2019-10-27T12:50:46.375Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"#随笔"},{"title":"标签","date":"2019-10-27T12:42:42.000Z","updated":"2019-10-27T12:44:37.134Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"can2serials_lib","slug":"can2serials-lib","date":"2019-10-27T14:43:46.000Z","updated":"2019-10-27T14:55:11.236Z","comments":true,"path":"2019/10/27/can2serials-lib/","link":"","permalink":"http://yoursite.com/2019/10/27/can2serials-lib/","excerpt":"","text":"CAN分析仪驱动 完成CAN到串口的数据解析，同时向CAN分析仪发送数据 数据解析流程：1.StarReading() : 开启ReadSerialPort()线程 2.ReadSerialPort() : 从serial读数据到buffer临时变量 3.BufferInComingData() : 遍历整个从串口读到的buffer，得到一帧完整的数据存于类成员data_buffer_（头+数据+校验位）后，按照通信协议调用parse()对数据含义进行解析 4.prase() : 解析一帧完整数据的含义，根据帧ID提取数据位。如果是下位机CAN消息，用canMsg_结构体变量存储CAN消息，并将其写入专门存放CAN消息的buffercanMsgBuf_[]中 整个ReadingSerilPort套在while循环下，保证线程持续读数据，解析数据。 取消字节对齐注意宏定义及其及使用 1#define PACK( __Declaration__ ) __Declaration__ __attribute__((__packed__))23PACK(4struct stdCanMsgPkg_t &#123;5 uint8_t header1; //666 uint8_t header2; //cc7 uint16_t pkg_len;8 uint8_t pkg_cmd; //B1 stdCanMsg9 uint8_t type; //frame type10 uint32_t frame_id;11 uint8_t frame_len;12 uint8_t data[8];13 uint8_t checknum;14&#125;);1516PACK(17struct inquireFilterResponsePkg_t &#123;18 uint8_t header1; //6619 uint8_t header2; //cc20 uint16_t pkg_len;21 uint8_t pkg_cmd; //9D inquire Filter Response 22 uint8_t result;23 uint8_t portNum;24 uint8_t filterNum;25 uint32_t filterID;26 uint32_t filterMask;27 uint8_t filterMode;28 uint8_t checknum;29&#125;); 在类成员函数中开启另外一个类成员函数的线程1void Can2serial::StartReading() 2&#123;3 if (reading_status_)4 return;5 6 //serial_port_-&gt;flush();7 // create thread to read from sensor8 reading_status_=true;9 read_thread_ptr_ = boost::shared_ptr&lt;boost::thread &gt;(new boost::thread(boost::bind(&amp;Can2serial::ReadSerialPort, this)));10&#125; 解析出一帧完整的数据包注意case2 case3 中 bytes_remaining的应用，该变量用于保存剩余未解析数据的长度 1void Can2serial::BufferIncomingData(unsigned char *message, unsigned int length)2&#123;3 // add incoming data to buffer4 for (unsigned int ii=0; ii&lt;length; ii++) 5 &#123;// make sure bufIndex is not larger than buffer6 if(buffer_index_&gt;=MAX_PKG_BUF_LEN)7 &#123;8 buffer_index_ = 0;9 printf(\"Overflowed receive buffer. Buffer cleared.\");10 &#125;11 //std::cout &lt;&lt; \"bytes_remaining_...:\" &lt;&lt;bytes_remaining_ &lt;&lt;std::endl;12 switch(buffer_index_)13 &#123;14 case 0: //nothing15 if(message[ii]==HeaderByte0)16 &#123;17 data_buffer_[buffer_index_++]=message[ii];18 &#125;19 bytes_remaining_ = 0;20 break;21 case 1:22 if(message[ii]==HeaderByte1)23 &#123;24 data_buffer_[buffer_index_++]=message[ii];25 bytes_remaining_ =2; //2 bytes pkgLen26 &#125;27 else28 &#123;29 buffer_index_=0;30 bytes_remaining_ =0;31 &#125;32 break;33 case 2:34 case 3:35 data_buffer_[buffer_index_++]=message[ii];36 bytes_remaining_ --;37 if(bytes_remaining_==0)38 &#123;39 package_len_ = (data_buffer_[buffer_index_-2] &lt;&lt; 8)+data_buffer_[buffer_index_-1] ;40 bytes_remaining_ = package_len_;41 if(bytes_remaining_ &gt; 16 || bytes_remaining_&lt;2)42 &#123;43 buffer_index_ = 0;44 break;45 &#125;46 //printf(\"\\t%x\\t%x\\n\",data_buffer_[buffer_index_-2],data_buffer_[buffer_index_-1]);47 &#125;48 break;49 default:50 data_buffer_[buffer_index_++]=message[ii];51 bytes_remaining_--;52 if(bytes_remaining_==0)53 &#123;54 //std::cout &lt;&lt; \"package_len_...:\" &lt;&lt;package_len_ &lt;&lt; std::endl;55 parse(data_buffer_,package_len_+4);56 buffer_index_ = 0;57 58 &#125;59 break;60 61 62 &#125;63 &#125; ntohl()，将网络字节顺序（大端模式）转换成主机顺序（intel，小端顺序）1case InquireFilterResponse:2 if((ntohl(inquire_filter_response_ptr_-&gt;filterID)&gt;&gt;21)!&#x3D;0)3 printf(&quot;filter_num:%x\\t filterID:%x\\t filterMask:%x\\r\\n&quot;,4 inquire_filter_response_ptr_-&gt;filterNum,ntohl(inquire_filter_response_ptr_-&gt;filterID)&gt;&gt;21,5 ntohl(inquire_filter_response_ptr_-&gt;filterMask)&gt;&gt;21); 串口初始化1static bool openSerial(serial::Serial* &amp; port_ptr, std::string port_name,int baud_rate)2&#x2F;&#x2F;这个地方传进来的是port_ptr引用,底下就可以修改了Serials对象了3&#123;4 try 5 &#123;6 port_ptr &#x3D; new serial::Serial(port_name,baud_rate,serial::Timeout::simpleTimeout(10)); 78 if (!port_ptr-&gt;isOpen())9 &#123;10 std::stringstream output;11 output &lt;&lt; &quot;Serial port: &quot; &lt;&lt; port_name &lt;&lt; &quot; failed to open.&quot; &lt;&lt; std::endl;12 delete port_ptr;13 port_ptr &#x3D; NULL;14 return false;15 &#125; 16 else 17 &#123;18 std::stringstream output;19 output &lt;&lt; &quot;Serial port: &quot; &lt;&lt; port_name &lt;&lt; &quot; opened successfully.&quot; &lt;&lt; std::endl;20 std::cout &lt;&lt; output.str() &lt;&lt;std::endl;21 &#125;2223 port_ptr-&gt;flush();24 &#125; 25 catch (std::exception &amp;e) 26 &#123;27 std::stringstream output;28 output &lt;&lt; &quot;Error &quot; &lt;&lt; port_name &lt;&lt; &quot;: &quot; &lt;&lt; e.what();29 std::cout &lt;&lt; output.str() &lt;&lt;std::endl;30 return false;31 &#125;32 33 return true; 线程锁，对CAN消息的读写操作时均需要1&#x2F;&#x2F;向canMSgBuf中写入数据2 &#123; 3 boost::mutex::scoped_lock lock(mutex_);4 canMsgBuf_[writeIndex_] &#x3D; canMsg_;5 canMsgStatus[writeIndex_] &#x3D; true;6&#125;78&#x2F;&#x2F;从canMsgBuf中读数据9&#123; 10 boost::mutex::scoped_lock lock(mutex_);11 msg &#x3D; canMsgBuf_[readIndex_];12 canMsgStatus[readIndex_]&#x3D;false;13 &#125;","categories":[{"name":"littleAntDriverless","slug":"littleAntDriverless","permalink":"http://yoursite.com/categories/littleAntDriverless/"}],"tags":[{"name":"CAN","slug":"CAN","permalink":"http://yoursite.com/tags/CAN/"}]},{"title":"建站前言","slug":"建站前言","date":"2019-10-27T07:35:39.000Z","updated":"2019-10-27T15:42:46.280Z","comments":true,"path":"2019/10/27/建站前言/","link":"","permalink":"http://yoursite.com/2019/10/27/%E5%BB%BA%E7%AB%99%E5%89%8D%E8%A8%80/","excerpt":"","text":"&emsp;花了整整一个下午加一晚上的时间来配置个人博客，从最初安装Nodejs，然后在github上部署hexo整个过程遇到了不少的坑。虽说花了不少时间，但还是学到了点东西也算值得。&emsp;这回费这么大劲建立个人博客的目的在于： 督促自己复盘每月甚至每周的生活； 每次看书或者有其它提升能力的时候，可以强迫自己写笔记记录下来，有助于思考； 每当遇到网络上搜索不到的问题，解决后记录防止以后再遇到此类问题； 记录一下自己的生活,帮助自己认清自己，也帮助其他人了解我这种社交网络小透明； *The one thing in my life I did right was giving my heart to you! My life has been so much better since the day that I was lucky enough to find you. *","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/%E6%80%9D%E8%80%83/"}]}]}